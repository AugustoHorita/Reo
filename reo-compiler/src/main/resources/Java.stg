main(S) ::= <<
/**
 * Generated from <S.file> by Reo 1.0.
 */
<! <S.package:package(); separator="\n"> !>
import nl.cwi.reo.runtime.java.*;

public class <S.name> {

  public static void main(String[] args) {
    
    <S.ports:newPort(); separator="\n">
    
    <S.components:newComponent(); separator="\n">
	
 	<S.components:newThread(); separator="\n"> 

	<S.components:start(); separator="\n">
	
    try {
      <S.components:join(); separator="\n">
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    
  }

  <S.components:component(); separator="\n\n">
  
}
>>

package(p) ::= <<
<if(p)>package <p>;<endif>
>>

newPort(p) ::= <<
Port\<<p.typeTag>\> <p.name> = new PortBusyWait\<<p.typeTag>\>();
>>

newComponent(c) ::= <<
Component <c.name> = new <c.name>(<c.ports:{p|<p.name>}; separator=", ">);
>>

newThread(c) ::= <<
Thread thread_<c.name> = new Thread(<c.name>);
>> 

start(c) ::= <<
thread_<c.name>.start();
>>

join(c) ::= <<
<if(!c.deamon)>thread_<c.name>.join();<endif>
>>

component(c) ::= <<
private class <c.name> implements Component {

	<c.ports:port(); separator="\n\n">
	
	<c.mem:memorycell(); separator="\n\n">
	
	<c:constructor()>
	
	<if(c.atomic)><c:atomic()><else><c:protocol()><endif>
}

>>

atomic(c) ::= <<
public synchronized void activate() {
	notify();
}

public void run() {
	<c.call>	
}
>>

protocol(c) ::= <<
public synchronized void activate() {
	notify();
}

public void run() {
	int k = 0;
	while (true) {
		k++;
		<c.transitions.keys:{k | <c.transitions.(k):transition()>}; separator="\n">
		if (k > 3) {
			k = 0;
			synchronized (this) {
				try { 
					wait(); 
				} catch (InterruptedException e) { }
			}	
		}
	}
}
>>

port(p) ::= <<
<! private volatile <if(p.input)>Input<else>Output<endif>Port\<<p.typeTag>\> <p.name>; !>
private volatile Port\<<p.typeTag>\> <p.name>;
>>

memorycell(m) ::= <<
private <m.type> <m.name>;
>>

constructor(c) ::= <<
public <c.name>(<c.ports:{p | Port\<<p.typeTag>\> <p.name>}; separator=", ">) {
	<c.ports:{p | <p.name>.<if(p.input)>setConsumer(this);<else>setProducer(this);<endif>}; separator="\n">
	<c.ports:{p | this.<p.name> = <p.name>;}; separator="\n">
	activate();
}
>>

transition(t) ::= <<
if (<guard(t); wrap, anchor>) {
	<action(t)>
	k = 0;
}
>>

guard(t) ::= <<
<t.guard:formula()>
<if(t.output.keys)> && <t.output.keys:{p | <p.name>.hasGet()}; separator=" && "><endif>
<if(t.input)> && <t.input:{p | <p.name>.hasPut()}; separator=" && "><endif>
>>

formula(f) ::= <<
<if(f.negation)>!(<f.formula:guard()>)
<elseif(t.guard.equality)>(<t.guard.t1:term()> == <t.guard.t2:term()>)
<elseif(t.guard.conjunction)>(<t.guard.clauses:guard(); separator=" && ">)
<elseif(t.guard.disjunction)>(<t.guard.clauses:guard(); separator=" || ">)
<endif>
>>

term(t) ::= <<
<if(t.function)><t.name>(<t.args:term(t); separator="\n">)
<elseif(t.constant)><t.name>
<elseif(t.port)><t.port.name>.get()
<elseif(t.memory)><t.name>
<else><t.name>
<endif>
>>

action(t) ::= <<
<t:output(); separator="\n">
<t:memory(); separator="\n">
<! <t.input:input(); separator="\n"> !>
>>

output(a) ::= <<
<a.output.keys:{p | <p.name>.put(<a.output.(p):term()>);}; separator="\n"> 
>>

memory(m) ::= <<
<m.memory.keys:{p | <p.name> = <m.memory.(p):term()>;}; separator="\n"> 
>>

input(p) ::= <<
<if(p.input)><p.name>.get();<endif>
>>

